### Композиция, логическая структура (диаграмма классов с описанием) и взаимодействия и состояния
В данной директории представлены диаграмма классов и их взаимосвязей + конечные автоматы состояний нашей игры

Пару комментариев к диаграммам классов:
  1) Все классы делятся на 2 типа -- интерфейсы и их непосредственные реализации -- хранение интерфейсов не то что запрещено (случай нулевого армора все еще есть) но крайне нежелательно
  2) Под "..." подразумевается целая куча реализаций вышеуказанного интерфейса, каждая из реализаций практически не отличается от других (лишь числовыми характеристиками, например показатель магического урона у оружий дальнего боя)

Комментарии насчет автоматов:
  1) Мы делали игру, поэтому конечный автомат является примером работы одного кадра, в автомате отсутствуют вызовы методов _draw/on_draw -- они выполняется после всех обновлений сверху вниз (от GameManager-a до мелких GameObject-ов таких как персонаж, снаряды, мобы и тп)
  2) Глобально наш проект -- непрерывный поток игровых событий (IGameAction) и их саморегуляция -- поэтому буквально в каждом из классов можно найти метод _update/on_update который занимается всегда одним и тем же -- создает либо сам (например: выход из комнаты, переход на следующий уровень и тп) либо с помошью объектов внутри себя (например: Room.objects -- игрок, мобы, снаряды, зелья, ключи и тп), поэтому во-первых конечный автомат (на мой взгляд) дает довольно плохое представление всего происходящего, во-вторых такая структура программ работающих с визуальным выводам весьма и весьма стандартна
  3) Пунктирные стрелки != переходы из одного состояния в другое -- так обыграны операции по добавлению в массивы
  4) По массивым из игровых событий (например: room.actions) мы на каждом кадре проходимся один раз и их "выполняем" (room.actions[i].room_handler) -- то есть то что там выделено в отдельную прямоугольную (не пунктирную) клетку == фор (поэтому мы можем в этот фор прийти из какого то состаяния, попасть обратно и выйти)
  5) KeyboardManager работает асинхронно -- в самом начале мы написали KeyboardManager.run() передали его в уровень (чтобы там обрабатывать) и забыли -- поэтому не стал добавлять
